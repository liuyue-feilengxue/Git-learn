# 设计概念：面向用户的
## 集中式模型
<p>集中式模型几居室一个客户端连接到服务器，如果有提交，就提交到服务器，服务器判断与前一个版本的差异，并将其作为更新，存储到仓库中。
<p>这个模型就会非常依赖服务器，<big>如果服务器不能被连接，用户就无法进行任何源管理操作。</big>

## 分布式模型

<p>在Git中，客户想与服务器端进行交互，将会复制客户端的一个副本，并将副本克隆，放到本地中。这个副本不仅仅包括了现在的情况，还包括了历史记录。

<p>本地仓库克隆了远程仓库以后，就可以对本地仓库进行所有的源管理操作。<big>就算无法连接服务器也可以进行。</big>当用户完成了他们想要的操作以后，就可以将本地仓库的东西提交到远程仓库。

***

# 设计概念：内部的

## 差异增量存储

<p>在传统的源管理系统中，内容是以逐个文件为基础来管理的。也就是说，每一个文件被作为仓库的独立实体来进行管理。当一组文件被首次添加到一个仓库中，每一个文件都会被作为单独的实体来保存。而如果有一个文件被改变了，系统就会自动的计算出每个文件新版本与之前的差异。然后将差异增量存储为新版本。
<p>简单的说，以一个<big>文件</big>为级别。检测到本文件哪里发生了改变，就改哪里，不用整个文件传过去。

<image >

## 快照存储
<p>Git使用了一个不一样的模型——快照模型。
<p>Git是在目录树级别追踪修订版本的。可以将Git仓库的每一个修订版本视作一个时间带你上目录树结构的切片——也就是快照。
<p>简单的说，就是以<big>整个项目</big>作为级别，发生改变的文件就与差异增量存储一样修改，（注意，这里不会存储差异增量，而是存储最新版本的文件）如果没有改变，则将上一次的东西连接过去本次快照。提交的时候是整个项目一起提交。
<p>注意，我们可能感觉Git这样做很消耗资源，但是，Git自己会采用一些算法来优化存储的时间以及空间。

## 差异增量存储与快照存储的区别
<p> 差异增量存储是通过逐个文件为基础进行管理的。而快照模型则是以目录树来管理。
<p> 差异增量模型会弄清楚差异并存储版本之间的差异信息。并且将从基础版本开始，用差异增量最后计算重构出最新版本的模型。而快照模型则不用重构。
